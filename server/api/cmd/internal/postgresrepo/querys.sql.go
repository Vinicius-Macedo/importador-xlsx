// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: querys.sql

package postgresrepo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserByEmail = `-- name: CountUserByEmail :one
SELECT COUNT(*) FROM users WHERE email = $1
`

func (q *Queries) CountUserByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserByEmail, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserByUsername = `-- name: CountUserByUsername :one
SELECT COUNT(*) FROM users WHERE username = $1
`

func (q *Queries) CountUserByUsername(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserByUsername, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateBenefitParams struct {
	BenefitKey     string      `json:"benefit_key"`
	BenefitOrderID pgtype.Text `json:"benefit_order_id"`
	BenefitType    pgtype.Text `json:"benefit_type"`
}

type CreateBillingParams struct {
	PartnerKey             pgtype.Text    `json:"partner_key"`
	CustomerKey            pgtype.Text    `json:"customer_key"`
	ProductKey             pgtype.Text    `json:"product_key"`
	PublisherKey           pgtype.Text    `json:"publisher_key"`
	SubscriptionKey        pgtype.Text    `json:"subscription_key"`
	MetersKey              pgtype.Text    `json:"meters_key"`
	ResourceUri            pgtype.Text    `json:"resource_uri"`
	EntitlementKey         pgtype.Text    `json:"entitlement_key"`
	BenefitKey             pgtype.Text    `json:"benefit_key"`
	Invoice                pgtype.Text    `json:"invoice"`
	UnitPrice              pgtype.Numeric `json:"unit_price"`
	Quantity               pgtype.Numeric `json:"quantity"`
	UnitType               pgtype.Text    `json:"unit_type"`
	BillingPreTaxTotal     pgtype.Numeric `json:"billing_pre_tax_total"`
	BillingCurrency        pgtype.Text    `json:"billing_currency"`
	PricingPreTaxTotal     pgtype.Numeric `json:"pricing_pre_tax_total"`
	PricingCurrency        pgtype.Text    `json:"pricing_currency"`
	EffectiveUnitPrice     pgtype.Numeric `json:"effective_unit_price"`
	PcToBcExchangeRate     pgtype.Numeric `json:"pc_to_bc_exchange_rate"`
	PcToBcExchangeRateDate pgtype.Date    `json:"pc_to_bc_exchange_rate_date"`
	ChargeStartDate        pgtype.Date    `json:"charge_start_date"`
	ChargeEndDate          pgtype.Date    `json:"charge_end_date"`
	UsageDate              pgtype.Date    `json:"usage_date"`
	ChargeType             pgtype.Text    `json:"charge_type"`
}

type CreateCustomerParams struct {
	CustomerKey string      `json:"customer_key"`
	Name        pgtype.Text `json:"name"`
	DomainName  pgtype.Text `json:"domain_name"`
	Country     pgtype.Text `json:"country"`
	TierToMpnID pgtype.Text `json:"tier_to_mpn_id"`
}

type CreateEntitlementParams struct {
	EntitlementKey string      `json:"entitlement_key"`
	Description    pgtype.Text `json:"description"`
}

type CreateMeterParams struct {
	MetersKey   string      `json:"meters_key"`
	Type        pgtype.Text `json:"type"`
	Category    pgtype.Text `json:"category"`
	SubCategory pgtype.Text `json:"sub_category"`
	Name        pgtype.Text `json:"name"`
	Region      pgtype.Text `json:"region"`
	Unit        pgtype.Text `json:"unit"`
}

type CreatePartnerParams struct {
	PartnerKey string      `json:"partner_key"`
	Name       pgtype.Text `json:"name"`
	MpnID      pgtype.Text `json:"mpn_id"`
}

type CreateProductParams struct {
	ProductKey string      `json:"product_key"`
	Name       pgtype.Text `json:"name"`
	SkuID      pgtype.Text `json:"sku_id"`
}

type CreatePublisherParams struct {
	PublisherKey string      `json:"publisher_key"`
	Name         pgtype.Text `json:"name"`
}

type CreateResourceParams struct {
	Uri             string      `json:"uri"`
	Location        pgtype.Text `json:"location"`
	ConsumedService pgtype.Text `json:"consumed_service"`
	ResourceGroup   pgtype.Text `json:"resource_group"`
	Info1           pgtype.Text `json:"info1"`
	Info2           pgtype.Text `json:"info2"`
	Tags            pgtype.Text `json:"tags"`
	AdditionalInfo  pgtype.Text `json:"additional_info"`
}

type CreateSkuParams struct {
	SkuKey         string      `json:"sku_key"`
	Name           pgtype.Text `json:"name"`
	AvailabilityID pgtype.Text `json:"availability_id"`
}

type CreateSubscriptionParams struct {
	SubscriptionKey string      `json:"subscription_key"`
	Description     pgtype.Text `json:"description"`
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (name, username, email, password) VALUES ($1, $2, $3, $4)
`

type CreateUserParams struct {
	Name     string `json:"name"`
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.Name,
		arg.Username,
		arg.Email,
		arg.Password,
	)
	return err
}

const getAllCustomers = `-- name: GetAllCustomers :many
SELECT
  customer_key,
  name,
  domain_name,
  country,
  tier_to_mpn_id
FROM
  customers
ORDER BY
  name
`

type GetAllCustomersRow struct {
	CustomerKey string      `json:"customer_key"`
	Name        pgtype.Text `json:"name"`
	DomainName  pgtype.Text `json:"domain_name"`
	Country     pgtype.Text `json:"country"`
	TierToMpnID pgtype.Text `json:"tier_to_mpn_id"`
}

func (q *Queries) GetAllCustomers(ctx context.Context) ([]GetAllCustomersRow, error) {
	rows, err := q.db.Query(ctx, getAllCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCustomersRow
	for rows.Next() {
		var i GetAllCustomersRow
		if err := rows.Scan(
			&i.CustomerKey,
			&i.Name,
			&i.DomainName,
			&i.Country,
			&i.TierToMpnID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllResources = `-- name: GetAllResources :many
SELECT
  id,
  uri,
  location,
  consumed_service,
  resource_group
FROM
  resources
ORDER BY
  resource_group
`

type GetAllResourcesRow struct {
	ID              int32       `json:"id"`
	Uri             string      `json:"uri"`
	Location        pgtype.Text `json:"location"`
	ConsumedService pgtype.Text `json:"consumed_service"`
	ResourceGroup   pgtype.Text `json:"resource_group"`
}

func (q *Queries) GetAllResources(ctx context.Context) ([]GetAllResourcesRow, error) {
	rows, err := q.db.Query(ctx, getAllResources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllResourcesRow
	for rows.Next() {
		var i GetAllResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.Uri,
			&i.Location,
			&i.ConsumedService,
			&i.ResourceGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT meters_key, type, category, sub_category, name, region, unit FROM meters ORDER BY category, sub_category, name
`

type GetCategoriesRow struct {
	MetersKey   string      `json:"meters_key"`
	Type        pgtype.Text `json:"type"`
	Category    pgtype.Text `json:"category"`
	SubCategory pgtype.Text `json:"sub_category"`
	Name        pgtype.Text `json:"name"`
	Region      pgtype.Text `json:"region"`
	Unit        pgtype.Text `json:"unit"`
}

func (q *Queries) GetCategories(ctx context.Context) ([]GetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesRow
	for rows.Next() {
		var i GetCategoriesRow
		if err := rows.Scan(
			&i.MetersKey,
			&i.Type,
			&i.Category,
			&i.SubCategory,
			&i.Name,
			&i.Region,
			&i.Unit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChargeMonths = `-- name: GetChargeMonths :many
SELECT
  DISTINCT EXTRACT(MONTH FROM charge_start_date) AS month,
  EXTRACT(YEAR FROM charge_start_date) AS year
FROM
  billings
ORDER BY
  year DESC,
  month DESC
`

type GetChargeMonthsRow struct {
	Month pgtype.Numeric `json:"month"`
	Year  pgtype.Numeric `json:"year"`
}

func (q *Queries) GetChargeMonths(ctx context.Context) ([]GetChargeMonthsRow, error) {
	rows, err := q.db.Query(ctx, getChargeMonths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChargeMonthsRow
	for rows.Next() {
		var i GetChargeMonthsRow
		if err := rows.Scan(&i.Month, &i.Year); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, username, email, password, created_at, updated_at, deleted_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, username, email, password, created_at, updated_at, deleted_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserPasswordByID = `-- name: UpdateUserPasswordByID :exec
UPDATE users SET password = $1 WHERE id = $2
`

type UpdateUserPasswordByIDParams struct {
	Password string `json:"password"`
	ID       int32  `json:"id"`
}

func (q *Queries) UpdateUserPasswordByID(ctx context.Context, arg UpdateUserPasswordByIDParams) error {
	_, err := q.db.Exec(ctx, updateUserPasswordByID, arg.Password, arg.ID)
	return err
}
