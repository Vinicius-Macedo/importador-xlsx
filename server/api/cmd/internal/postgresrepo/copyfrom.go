// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: copyfrom.go

package postgresrepo

import (
	"context"
)

// iteratorForCreateBenefit implements pgx.CopyFromSource.
type iteratorForCreateBenefit struct {
	rows                 []CreateBenefitParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateBenefit) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateBenefit) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].BenefitKey,
		r.rows[0].BenefitOrderID,
		r.rows[0].BenefitType,
	}, nil
}

func (r iteratorForCreateBenefit) Err() error {
	return nil
}

func (q *Queries) CreateBenefit(ctx context.Context, arg []CreateBenefitParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"benefits"}, []string{"benefit_key", "benefit_order_id", "benefit_type"}, &iteratorForCreateBenefit{rows: arg})
}

// iteratorForCreateBilling implements pgx.CopyFromSource.
type iteratorForCreateBilling struct {
	rows                 []CreateBillingParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateBilling) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateBilling) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].PartnerKey,
		r.rows[0].CustomerKey,
		r.rows[0].ProductKey,
		r.rows[0].PublisherKey,
		r.rows[0].SubscriptionKey,
		r.rows[0].MetersKey,
		r.rows[0].ResourceUri,
		r.rows[0].EntitlementKey,
		r.rows[0].BenefitKey,
		r.rows[0].Invoice,
		r.rows[0].UnitPrice,
		r.rows[0].Quantity,
		r.rows[0].UnitType,
		r.rows[0].BillingPreTaxTotal,
		r.rows[0].BillingCurrency,
		r.rows[0].PricingPreTaxTotal,
		r.rows[0].PricingCurrency,
		r.rows[0].EffectiveUnitPrice,
		r.rows[0].PcToBcExchangeRate,
		r.rows[0].PcToBcExchangeRateDate,
		r.rows[0].ChargeStartDate,
		r.rows[0].ChargeEndDate,
		r.rows[0].UsageDate,
		r.rows[0].ChargeType,
	}, nil
}

func (r iteratorForCreateBilling) Err() error {
	return nil
}

func (q *Queries) CreateBilling(ctx context.Context, arg []CreateBillingParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"billings"}, []string{"partner_key", "customer_key", "product_key", "publisher_key", "subscription_key", "meters_key", "resource_uri", "entitlement_key", "benefit_key", "invoice", "unit_price", "quantity", "unit_type", "billing_pre_tax_total", "billing_currency", "pricing_pre_tax_total", "pricing_currency", "effective_unit_price", "pc_to_bc_exchange_rate", "pc_to_bc_exchange_rate_date", "charge_start_date", "charge_end_date", "usage_date", "charge_type"}, &iteratorForCreateBilling{rows: arg})
}

// iteratorForCreateCustomer implements pgx.CopyFromSource.
type iteratorForCreateCustomer struct {
	rows                 []CreateCustomerParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCustomer) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCustomer) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].CustomerKey,
		r.rows[0].Name,
		r.rows[0].DomainName,
		r.rows[0].Country,
		r.rows[0].TierToMpnID,
	}, nil
}

func (r iteratorForCreateCustomer) Err() error {
	return nil
}

func (q *Queries) CreateCustomer(ctx context.Context, arg []CreateCustomerParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"customers"}, []string{"customer_key", "name", "domain_name", "country", "tier_to_mpn_id"}, &iteratorForCreateCustomer{rows: arg})
}

// iteratorForCreateEntitlement implements pgx.CopyFromSource.
type iteratorForCreateEntitlement struct {
	rows                 []CreateEntitlementParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateEntitlement) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateEntitlement) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].EntitlementKey,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForCreateEntitlement) Err() error {
	return nil
}

func (q *Queries) CreateEntitlement(ctx context.Context, arg []CreateEntitlementParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"entitlements"}, []string{"entitlement_key", "description"}, &iteratorForCreateEntitlement{rows: arg})
}

// iteratorForCreateMeter implements pgx.CopyFromSource.
type iteratorForCreateMeter struct {
	rows                 []CreateMeterParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateMeter) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateMeter) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].MetersKey,
		r.rows[0].Type,
		r.rows[0].Category,
		r.rows[0].SubCategory,
		r.rows[0].Name,
		r.rows[0].Region,
		r.rows[0].Unit,
	}, nil
}

func (r iteratorForCreateMeter) Err() error {
	return nil
}

func (q *Queries) CreateMeter(ctx context.Context, arg []CreateMeterParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"meters"}, []string{"meters_key", "type", "category", "sub_category", "name", "region", "unit"}, &iteratorForCreateMeter{rows: arg})
}

// iteratorForCreatePartner implements pgx.CopyFromSource.
type iteratorForCreatePartner struct {
	rows                 []CreatePartnerParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreatePartner) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreatePartner) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].PartnerKey,
		r.rows[0].Name,
		r.rows[0].MpnID,
	}, nil
}

func (r iteratorForCreatePartner) Err() error {
	return nil
}

func (q *Queries) CreatePartner(ctx context.Context, arg []CreatePartnerParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"partners"}, []string{"partner_key", "name", "mpn_id"}, &iteratorForCreatePartner{rows: arg})
}

// iteratorForCreateProduct implements pgx.CopyFromSource.
type iteratorForCreateProduct struct {
	rows                 []CreateProductParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProduct) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProduct) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProductKey,
		r.rows[0].Name,
		r.rows[0].SkuID,
	}, nil
}

func (r iteratorForCreateProduct) Err() error {
	return nil
}

func (q *Queries) CreateProduct(ctx context.Context, arg []CreateProductParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"products"}, []string{"product_key", "name", "sku_id"}, &iteratorForCreateProduct{rows: arg})
}

// iteratorForCreatePublisher implements pgx.CopyFromSource.
type iteratorForCreatePublisher struct {
	rows                 []CreatePublisherParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreatePublisher) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreatePublisher) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].PublisherKey,
		r.rows[0].Name,
	}, nil
}

func (r iteratorForCreatePublisher) Err() error {
	return nil
}

func (q *Queries) CreatePublisher(ctx context.Context, arg []CreatePublisherParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"publishers"}, []string{"publisher_key", "name"}, &iteratorForCreatePublisher{rows: arg})
}

// iteratorForCreateResource implements pgx.CopyFromSource.
type iteratorForCreateResource struct {
	rows                 []CreateResourceParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateResource) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateResource) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Uri,
		r.rows[0].Location,
		r.rows[0].ConsumedService,
		r.rows[0].ResourceGroup,
		r.rows[0].Info1,
		r.rows[0].Info2,
		r.rows[0].Tags,
		r.rows[0].AdditionalInfo,
	}, nil
}

func (r iteratorForCreateResource) Err() error {
	return nil
}

func (q *Queries) CreateResource(ctx context.Context, arg []CreateResourceParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"resources"}, []string{"uri", "location", "consumed_service", "resource_group", "info1", "info2", "tags", "additional_info"}, &iteratorForCreateResource{rows: arg})
}

// iteratorForCreateSku implements pgx.CopyFromSource.
type iteratorForCreateSku struct {
	rows                 []CreateSkuParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateSku) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateSku) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SkuKey,
		r.rows[0].Name,
		r.rows[0].AvailabilityID,
	}, nil
}

func (r iteratorForCreateSku) Err() error {
	return nil
}

func (q *Queries) CreateSku(ctx context.Context, arg []CreateSkuParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"skus"}, []string{"sku_key", "name", "availability_id"}, &iteratorForCreateSku{rows: arg})
}

// iteratorForCreateSubscription implements pgx.CopyFromSource.
type iteratorForCreateSubscription struct {
	rows                 []CreateSubscriptionParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateSubscription) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateSubscription) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SubscriptionKey,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForCreateSubscription) Err() error {
	return nil
}

func (q *Queries) CreateSubscription(ctx context.Context, arg []CreateSubscriptionParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"subscriptions"}, []string{"subscription_key", "description"}, &iteratorForCreateSubscription{rows: arg})
}
